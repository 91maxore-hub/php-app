# Bygg och distribuera en webapp med Docker och Github Actions

Detta projekt best√•r av en enkel webbapplikation byggd med PHP och Nginx som k√∂rs i en Docker-container. Applikationen √§r ett kontaktformul√§r f√∂r f√∂retaget Wavvy AB d√§r anv√§ndare kan skicka meddelanden till f√∂retagets support. Frontend √§r stilren och responsiv med CSS, och efter inskickat formul√§r visas ett bekr√§ftelsemeddelande.

Docker-imagen baseras p√• PHP 8.2 med PHP-FPM och Nginx, och applikationen √§r konfigurerad f√∂r att k√∂ra PHP via FastCGI. Applikationen k√∂rs tillsammans med en omv√§nd proxy (nginx-proxy) som hanterar inkommande trafik och vidarebefordrar den till r√§tt container. SSL-certifikat hanteras automatiskt via Let's Encrypt och en certifikatkompanjon.

Hela bygg- och deployprocessen √§r automatiserad med GitHub Actions. Vid varje push till master-grenen byggs en ny Docker-image, pushas till Docker Hub och deployas via SSH till en server d√§r Docker Compose startar om containrarna med den nya versionen. Milj√∂variabler f√∂r dom√§n och certifikat hanteras s√§kert via GitHub Secrets.

GitHub Repo: https://github.com/91maxore-hub/php-app

üõ†Ô∏è Steg 1 ‚Äì Skapandet av projektstruktur och grundfiler

| Fil / Mapp      | Typ  | Beskrivning                       |
| --------------- | ---- | --------------------------------- |
| `php-app/`      | Mapp | Projektets rotmapp                |
| ‚îú‚îÄ‚îÄ `index.php` | Fil  | Huvudfil f√∂r webbapplikationen    |
| ‚îú‚îÄ‚îÄ `style.css` | Fil  | CSS-stilmall f√∂r sidans utseende  |
| ‚îî‚îÄ‚îÄ `logo2.png` | Fil  | Bildfil ‚Äì logotyp f√∂r webbplatsen |

Syftet med dessa filer var att skapa en minimal men fungerande webbsida som kunde paketeras i en Docker-image. index.php inneh√•ller sj√§lva inneh√•llet f√∂r sidan, style.css st√•r f√∂r designen, och logo2.png anv√§nds logobild f√∂r webbplatsen.

Steg 2: Paketera som Docker Image och ladda upp till Docker Hub

Efter att projektstrukturen var klar (med index.php, style.css, logo2.png), gick jag vidare till att paketera projektet i en Docker-image och publicera den p√• Docker Hub.
Jag b√∂rjade f√∂rst med att skapa ett repo p√• Docker Hub som ska h√•lla min Docker-image som jag d√∂pte till **php-nginx-app**

![alt text](image.png)

Jag skapade d√§refter en Dockerfile som installerar PHP 8.2 med FPM, Nginx, och kopierar in mina filer samt en egen Nginx-konfiguration:

```Dockerfile
# Anv√§nd officiell PHP 8.2 FPM image som bas (PHP med FastCGI Process Manager)
FROM php:8.2-fpm

# Uppdatera paketlistan och installera Nginx webbserver
RUN apt-get update && \
    apt-get install -y nginx && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*  # Rensa cache f√∂r att h√•lla image liten

# Ta bort standardfiler i Nginx webbroot f√∂r att undvika att visa standardstartsidan
RUN rm -rf /var/www/html/*

# Kopiera applikationens filer fr√•n din dator till containerns webbrot
COPY . /var/www/html

# Byt arbetskatalog till webbrot, d√§r index.php ligger
WORKDIR /var/www/html

# Kopiera din egen Nginx-konfiguration till standardplats
COPY default.conf /etc/nginx/sites-available/default

# Exponera port 80 f√∂r webbtrafik utanf√∂r containern
EXPOSE 80

# Starta php-fpm i bakgrunden och nginx i f√∂rgrunden
CMD ["bash", "-c", "php-fpm & nginx -g 'daemon off;'"]
```

Jag skapade √§ven en fil default.conf d√§r jag konfigurerade Nginx att peka p√• r√§tt katalog och hantera PHP-filer.

```default.conf
server {
    listen 80;
    server_name localhost;
    root /var/www/html;

    index index.php index.html index.htm;

    location / {
        try_files $uri $uri/ =404;
    }

    location ~ \.php$ {
        include snippets/fastcgi-php.conf;
        fastcgi_pass 127.0.0.1:9000;
    }

    location ~ /\.ht {
        deny all;
    }
}
```

Byggandet av Docker Image
I terminalen k√∂rde jag f√∂ljande kommando i projektmappen (d√§r mina samtliga filer finns) f√∂r att bygga mina projektfiler till en Docker Image

```bash
docker build -t 91maxore/php-nginx-app:latest .
```

Loggade in p√• Docker Hub
Jag loggade in med:
```bash
docker login
```

Och angav mitt anv√§ndarnamn och l√∂senord som jag anv√§nder till Docker Hub.

üöÄ Pushade Docker Image till Docker Hub
```bash
docker push 91maxore/php-nginx-app:latest
```

Detta pushar min nyskapade Docker Image till Docker Hub och √§r redo f√∂r anv√§ndning.
Nu ligger den p√• Docker Hub:

üîó https://hub.docker.com/repository/docker/91maxore/php-nginx-app/

**K√∂ra containern lokalt**
F√∂r att f√∂rst testa att containern fungerar som den ska, k√∂rde jag den med:
```bash
docker run -d -p 8080:80 91maxore/php-nginx-app:latest
```

Notera: Att jag k√∂r Docker imagen mot port 8080

Sedan kunde jag √∂ppna webappen i webbl√§saren via:
```bash
http://localhost:8080
```

D√§r laddades min PHP-webapp utan konstigheter.

![alt text](image-1.png)

**Steg 3: K√∂ra i en Container Host**

Efter att jag byggt och laddat upp Docker-imagen till Docker Hub var n√§sta steg att k√∂ra webappen i en container p√• en containerhost.

Jag testade detta lokalt (som du kan l√§sa ovan) och det fungerade. S√• n√§sta steg √§r att f√• en Azure VM att k√∂ra containern, s√• att appen kan n√•s d√§rifr√•n via sitt publika IP hela tiden.

**Konfiguration av Container Host**

| **Parameter**  | **V√§rde**                          |
| -------------- | ---------------------------------- |
| **Namn**       | PHP-APP-VM                         |
| **Region**     | North Europe                       |
| **Image**      | Ubuntu Server 22.04 LTS ‚Äì x64 Gen2 |
| **Storlek**    | Standard\_B1s (1 vCPU, 1 GiB RAM)  |
| **Publikt IP** | 4.231.236.186                      |

Steg 1: Logga in p√• servern via SSH:
```bash
ssh -i ~/Downloads/php-VM_key.pem azureuser@4.231.236.186
```

Steg 2: Installera Docker:
```bash
sudo apt update
sudo apt install docker.io -y
```

Steg 3: K√∂r containern:
```bash
docker run -d -p 80:80 91maxore/php-nginx-app:latest
```

Notera att jag inte beh√∂vde utf√∂ra docker login eftersom docker imagen √§r publik.
Dessutom k√∂r vi containern p√• port 80 s√• att man slipper ange porten efter ip-adressen.

Steg 4: G√• till serverns IP-adress i webbl√§saren:
```bash
http://4.231.236.186
```

![alt text](image-2.png)

Notera att appen √§r √•tkomlig via serverns publika IP.
Det √§r viktigt att notera att port 80 (f√∂r HTTP) beh√∂ver vara √∂ppen i brandv√§ggen p√• Azure.

üîÑ Kontrollera att containern k√∂rs
F√∂r att se om containern √§r ig√•ng kan du anv√§nda:

```bash
docker ps
```

Du ser d√• n√•got liknande:

![alt text](image-3.png)

Nu har jag flera container som k√∂rs eftersom jag k√∂r reverse proxy + HTTPS/SSL. Men dit kommer vi senare, men du f√∂rst√•r po√§ngen.

F√∂r att stoppa och ta bort containern, kan du utf√∂ra f√∂ljande:
```bash
docker stop <container-id>
docker rm <container-id>
```

T√§nk p√• att du kan beh√∂va anv√§nda sudo om du inte har root-permissions.

üåê Steg 4: Anv√§nda dom√§nnamn ist√§llet f√∂r IP (wavvy.se via Loopia)

F√∂r att g√∂ra webappen tillg√§nglig via ett eget dom√§nnamn, valde jag att koppla dom√§nen wavvy.se, som jag k√∂pt via Loopia, till min server ist√§llet f√∂r att anv√§nda en publik IP-adress direkt. Fr√§mst eftersom jag inte vill exponera serverns publika IP.

Jag loggade in p√• Loopia och gick till DNS-inst√§llningarna f√∂r dom√§nen. D√§r uppdaterade jag A-posten s√• att wavvy.se pekar p√• min servers publika IP-adress. Efter en stund kunde appen n√•s via http://wavvy.se

![alt text](image-4.png)

üîÅ Steg 5: Reverse Proxy och HTTPS med Docker + Let's Encrypt

F√∂r att s√§kra min webbapp och g√∂ra den tillg√§nglig via HTTPS, satte jag upp en reverse proxy med automatiskt SSL-certifikat fr√•n Let's Encrypt.

**Jag anv√§nde tre containrar:**

1. Min php-nginx-app (fr√•n Docker Hub)
2. nginx-proxy ‚Äì reverse proxy som lyssnar p√• trafik och omdirigerar till r√§tt container
3. letsencrypt-nginx-proxy-companion ‚Äì genererar och hanterar SSL-certifikat automatiskt

üß± docker-compose.yml

Jag skapade en docker-compose.yml som definierade alla tre containrar:

```yaml
version: '3'

services:
  app:
    image: 91maxore/php-nginx-app:latest
    container_name: my-php-app
    restart: unless-stopped
    expose:
      - "80"
    environment:
      - VIRTUAL_HOST=${VIRTUAL_HOST}
      - LETSENCRYPT_HOST=${LETSENCRYPT_HOST}
      - LETSENCRYPT_EMAIL=${LETSENCRYPT_EMAIL}
    networks:
      - webnet

  reverse-proxy:
    image: jwilder/nginx-proxy
    container_name: nginx-proxy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/tmp/docker.sock:ro
      - ./certs:/etc/nginx/certs:ro
      - ./vhost.d:/etc/nginx/vhost.d
      - ./html:/usr/share/nginx/html
    networks:
      - webnet

  letsencrypt:
    image: jrcs/letsencrypt-nginx-proxy-companion
    container_name: nginx-proxy-acme
    restart: unless-stopped
    environment:
      - NGINX_PROXY_CONTAINER=nginx-proxy
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./certs:/etc/nginx/certs:rw
      - ./vhost.d:/etc/nginx/vhost.d
      - ./html:/usr/share/nginx/html
    networks:
      - webnet

networks:
  webnet:
    driver: bridge
```

**üîê Automatisk HTTPS med milj√∂variabler**

F√∂r att konfigurera SSL och dom√§nnamnet anv√§nde jag tre milj√∂variabler som app-containern l√§ser in:

1. VIRTUAL_HOST ‚Äì dom√§nnamnet (wavvy.se)
2. LETSENCRYPT_HOST ‚Äì dom√§nnamnet som certifikatet ska utf√§rdas f√∂r (wavvy.se)
3. LETSENCRYPT_EMAIL ‚Äì min e-postadress f√∂r Let's Encrypt (91maxore@gafe.molndal.se)

Dessa v√§rden sattes i en .env-fil, som genereras automatiskt av GitHub Actions under deployment.

**üöÄ Automatiserad deploy med GitHub Actions**

F√∂r att f√∂renkla processen byggde och pushade jag min Docker-image automatiskt via GitHub Actions, och deployade sedan direkt till servern via SSH.

Workflow-filen (.github/workflows/docker-image.yml) g√∂r f√∂ljande:

1. Bygger Docker-imagen
2. Pushar den till Docker Hub
3. Ansluter till servern via SSH
4. Skapar .env-fil med hj√§lp av GitHub Secrets
5. Startar eller uppdaterar containrarna med docker-compose up -d

Nedan √§r ett utdrag som g√∂r just detta jag n√§mnde precis.

```yaml
- name: üöÄ Deploya till server
  uses: appleboy/ssh-action@v0.1.7
  with:
    host: ${{ secrets.SERVER_HOST }}
    username: ${{ secrets.SERVER_USER }}
    key: ${{ secrets.SERVER_SSH_KEY }}
    script: |
      cd /home/azureuser/nginx-reverse-proxy

      echo "VIRTUAL_HOST=${{ secrets.VIRTUAL_HOST }}" > .env
      echo "LETSENCRYPT_HOST=${{ secrets.LETSENCRYPT_HOST }}" >> .env
      echo "LETSENCRYPT_EMAIL=${{ secrets.LETSENCRYPT_EMAIL }}" >> .env

      sudo docker-compose pull
      sudo docker-compose up -d
```

Jag lagrar alla k√§nsliga v√§rden (IP, dom√§n, SSH-nyckel, e-post) som GitHub Secrets i repo-inst√§llningarna.

![alt text](image-5.png)

| üîí **Secret**        | üí¨ **Beskrivning / V√§rde**                                                            |
| -------------------- | -------------------------------------------------------------------------------------- |
| `DOCKERHUB_USERNAME` | **Anv√§ndarnamn f√∂r Docker Hub** ‚Äì `91maxore`                                           |
| `DOCKERHUB_TOKEN`    | **Access token f√∂r Docker Hub**                                                        |
| `SERVER_HOST`        | **Serverns IP-adress** ‚Äì `4.231.236.186`                                               |
| `SERVER_USER`        | **Anv√§ndare f√∂r SSH-anslutning till servern** ‚Äì `azureuser`                            |
| `SERVER_SSH_KEY`     | **Privat SSH-nyckel** ‚Äì anv√§nds av GitHub Actions f√∂r att logga in p√• servern via SSH  |
| `VIRTUAL_HOST`       | **Dom√§nnamn f√∂r webbappen** ‚Äì `wavvy.se`                                               |
| `LETSENCRYPT_HOST`   | **Dom√§n f√∂r SSL-certifikat (Let's Encrypt)** ‚Äì `wavvy.se`                              |
| `LETSENCRYPT_EMAIL`  | **E-postadress f√∂r certifikatregistrering och f√∂rnyelse** ‚Äì `91maxore@gafe.molndal.se` |


‚úÖ Resultat

Efter att allt var uppsatt kunde jag g√• till:
üîó https://wavvy.se

Min PHP-webapp laddas med giltigt SSL-certifikat, automatisk HTTPS och reverse proxy som hanterar trafiken smidigt.
Allt detta sker helt automatiskt ‚Äì b√•de deployment och certifikatf√∂rnyelse.